package hub.sam.sdlplus.semantics;

import hub.sam.models.sdlplusconcretesyntaxextensions.*;
import hub.sam.models.common.*;
import hub.sam.models.commondata.*;
import hub.sam.models.commonbehaviour.*;
import hub.sam.models.sdlplus.*;
import hub.sam.mopa.trees.*;
import java.util.*;
import cmof.reflection.Extent;
import cmof.common.ReflectiveCollection;

public class ResolveConcreteSyntaxExtensions {

    private NameTable names;
    private Extent oExtent;
    private List<SemanticError> errors;
    private Iterable<TreeNode> model;
    private Set<cmof.reflection.Object> deletedElements = new HashSet<cmof.reflection.Object>();
    private hub.sam.models.common.commonFactory commonFactory;

	/**
	 * Creates a ModelTransformator for oExtent. All errors that are encountered in further transformation steps
	 * are added to errors.
	 */
    public ResolveConcreteSyntaxExtensions(hub.sam.mof.Repository repository, Extent metaExtent, Extent oExtent, List<SemanticError> errors) {
        this.oExtent = oExtent;
        this.errors = errors;
        this.commonFactory = (hub.sam.models.common.commonFactory)repository.createFactory(oExtent, (cmof.Package)metaExtent.query("Package:Common"));
        System.out.println("Generating MOPA trees for WCSE extent.");
        model = hub.sam.mof.mopatree.Mof2TreeNode.createNodes(oExtent.outermostComposites());
        names = new NameTable(model);
    }

    /**
	 * Transforms the model by resolving StringReferences. When a reference could not be resolved a
	 * SemanticError is created and added to the list of errors.
	 */
    public void resolveSdlIdentifier() {
        System.out.println("Resolve identifier.");
        resolveSdlIdentifiers(model);
        for(cmof.reflection.Object elementToDelete: deletedElements) {            
            elementToDelete.delete();
        }
    }

	/**
	 * Creates implicit Interfaces for all instances and type. When a type specifies an interface type
	 * (eg. Gates in AgentTypes) then this tranformation will add an according interface (interface type instance) in
	 * each instance of that type. Furthermore a special interfaces "this" will be created in every type. This thisinterfaces
	 * can be used intern by type to access according type instances.
	 */
    public void createInterfaces() {
        //System.out.println("Create implicit interface type for state types.");
        //createImplicitInterfaceTypesForStateTypes(JMITreeNode.forrestForPackage(oExtent));
        System.out.println("Create interfaces.");
        createInterfaces(hub.sam.mof.mopatree.Mof2TreeNode.createNodes(oExtent.outermostComposites()));
    }

    /**
     * Resolves the ends of SDL channels. A channel end references a gate in a type instance, or more exactly an interface
     * (an instance of an gate). This transformation connects the channel ends with the interfaces of the instances that they
     * specifiy. In case of a channel end THIS, the channel is connected to the according thisinterface. Cf. createInterfaces.
     */
    public void resolveChannelEndPointBindings() {
        System.out.println("Resolve ChannelEndPoint bindings.");
        resolveChannelEndPointBindings(hub.sam.mof.mopatree.Mof2TreeNode.createNodes(oExtent.outermostComposites()));
    }

    private void errorNoIndentified(Identifier identifier) {
        errors.add(new SemanticError((cmof.reflection.Object)identifier, "identifier reference a non existing element"));
    }

    private void errorWrongIdentified(Identifier identifier, NamedElement identified, java.lang.Class reqType) {
        errors.add(new SemanticError((cmof.reflection.Object)identifier, "identifier reference element of wrong type " +
                identified.getClass().getName() + ", it should reference to a " + reqType.getName()));
    }

    private void errorCannotDetermineTypeOfExpression(Expression expr) {
        errors.add(new SemanticError((cmof.reflection.Object)expr, "unable to determine the type of the expression"));
    }

    /**
     * This is to certify that element type has allready been checked for cses, and all cses have allready be resolved.
     * When not this method will trigger the resolve process. All this is nessesary because of the undetermed order of the
     * elements.
     */
    private void checkIfValueDataTypeIsResolved(cmof.reflection.Object resolved, ModelElement resolvee) {
        if (!(resolved instanceof ValueDataType)) {
            resolveSdlIdentifiers(hub.sam.mof.mopatree.Mof2TreeNode.createNode((cmof.reflection.Object)resolvee));
        }
    }

    private pattern ValueDataType determineTypeOfExpression() {
        OperationApplication(operation=type:Operation) -> {
            return (ValueDataType)operation.getContainer();
        }
        LiteralExpression(literal=literal:Literal) -> {
            return (ValueDataType)literal.getDataType();
        }
        AnyExpression -> {
            //TBD
            return null;
        }
        SdlVariableAccess(variable=variable:Variable) -> {
            checkIfValueDataTypeIsResolved((cmof.reflection.Object)variable.getType(), variable);
            if (variable.getType() instanceof ValueDataType) {
                  return (ValueDataType)variable.getType();
            } else {
                return null;
            }
        }
        expr=Expression provided ( expr.determineType() instanceof ValueDataType) -> {
            return (ValueDataType)expr.determineType();
        }
        default -> {
            System.err.println("unreachable code - 1");
            return null;
        }
    }

    private pattern void resolveSdlIdentifiers() {
        referencee=Assignment(referenced=variable:CsePlaceHolderForVariable(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "variable", false, Variable.class);
            dive;
            break pattern;
        }

        referencee=LiteralExpression(referenced=literal:CsePlaceHolderForLiteral(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "literal", false, Literal.class);
            dive;
            break pattern;
        }

        referencee=OutputNode(referenced=viaGate:CsePlaceHolderForGateDefinition(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "viaGate", false, GateDefinition.class);
            dive;
        }

        referencee=OutputNode(referenced=type:CsePlaceHolderForNamedElement(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "type", false, SignalDefinition.class);
            dive;
        }

        referencee=InputNode(referenced=type:CsePlaceHolderForNamedElement(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "type", false, SignalDefinition.class);
            dive;
        }

        referencee=VariableAccess(referenced=variable:CsePlaceHolderForVariable(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "variable", false,
                    Variable.class);
            dive;
            break pattern;
        }

        referencee=CallNode(referenced=type:CsePlaceHolderForNamedElement(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "type", false,
                    ProcedureDefinition.class);
            dive;
            break pattern;
        }

        referencee=OperationApplication(referenced=type:CsePlaceHolderForNamedElement(
                reference=stringReference:Identifier)) -> {
            dive; // the expression arguments have to be evaluated first, in order to determine the type of arguments
            ValueDataType typeOfArgument = null;
            try {
                typeOfArgument = determineTypeOfExpression(
                    hub.sam.mof.mopatree.Mof2TreeNode.createNode((cmof.reflection.Object)referencee.getOperands().get(0)));
            } catch (Exception e) {
                // empty
            }
            if (typeOfArgument == null) {
                errorCannotDetermineTypeOfExpression((Expression)
                        referencee.getOperands().get(0));
                break pattern;
            }
            NamedElement identified = names.resolveAIdentifierInContainer(reference, typeOfArgument, Operation.class);
            if (identified == null) {
                errorNoIndentified(reference);
            } else {
                referencee.setType(identified);
                deletedElements.add((cmof.reflection.Object)referenced);
            }
            break pattern;
        }

        referencee=SdlTransition(referenced=nextState:CsePlaceHolderForState(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "nextState", false, State.class);
            dive;
            break pattern;
        }

        referencee=Media(referenced=items:CsePlaceHolderForComItem(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "items", true, ComItem.class);
            dive;
        }

        referencee=InterfaceType(referenced=receive:CsePlaceHolderForComItem(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "receive", true, ComItem.class);
            dive;
        }

        referencee=InterfaceType(referenced=send:CsePlaceHolderForComItem(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "send", true, ComItem.class);
            dive;
        }

        referencee=AgentDefinition(referenced=type:CsePlaceHolderForNamedElement(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "type", false, AgentTypeDefinition.class);
            dive;
            break pattern;
        }

        referencee=CallNode(referenced=type:CsePlaceHolderForNamedElement(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "type", false, ProcedureDefinition.class);
            dive;
            break pattern;
        }

        referencee=CreateRequestNode(referenced=type:CsePlaceHolderForNamedElement(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "type", false, AgentDefinition.class);
            dive;
            break pattern;
        }

        referencee=ResetNode(referenced=type:CsePlaceHolderForNamedElement(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "type", false, TimerDefinition.class);
            dive;
        }

        referencee=StateMachineDefinition(referenced=type:CsePlaceHolderForNamedElement(
                reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "type", false, CompositeStateTypeDefinition.class);
            dive;
            break pattern;
        }

        referencee=OpenRange(referenced=type:CsePlaceHolderForNamedElement(reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "type", false, Operation.class);
            dive;
            break pattern;
        }

        referencee=Source(referenced=items:CsePlaceHolderForComItem(reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "items", true, ComItem.class);
            dive;
        }

        referencee=Sink(referenced=items:CsePlaceHolderForComItem(reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "items", true, ComItem.class);
            dive;
        }

        referencee=TypeReference(referenced=type:CsePlaceHolderForNamedElement(reference=stringReference:Identifier)) -> {
            resolveReference(referencee, reference, referenced, "type", false, ValueDataType.class);
            dive;
            break pattern;
        }

        oObject=cmof.reflection.Object -> {
            dive;
            break pattern;
        }
    }

    private void resolveReference(ModelElement referencee, Identifier reference,
            ModelElement referenced, String property, boolean isListProperty, Class referenceTypeConstraint) {
        NamedElement identified = names.resolveAIdentifier(reference, referencee, referenceTypeConstraint);
        if (checkIdentified(identified, reference, referenceTypeConstraint)) {
            if (isListProperty) {
                ((ReflectiveCollection)((cmof.reflection.Object)referencee).get(property)).remove(referenced);
                ((ReflectiveCollection)((cmof.reflection.Object)referencee).get(property)).add(identified);
            } else {
                ((cmof.reflection.Object)referencee).set(property, identified);
                if (((cmof.reflection.Object)referencee).get(property) != identified) {
                    throw new RuntimeException("There is still a MDR bug");
                }
            }
            deletedElements.add((cmof.reflection.Object)referenced);
        }
    }

    private boolean checkIdentified(NamedElement identified, Identifier reference, Class referenceTypeConstraint) {
        if (identified == null) {
            errorNoIndentified(reference);
        } else if (!referenceTypeConstraint.isAssignableFrom(identified.getClass())) {
            errorWrongIdentified(reference, identified, referenceTypeConstraint);
        } else {
            return true;
        }
        return false;
    }

    private pattern void createInterfaces() {
        interfaceType=InterfaceType -> {
            Interface thisInterface = commonFactory.createInterface();
            thisInterface.setIsPositive(false);
            thisInterface.setLine(interfaceType.getLine());
            thisInterface.setColumn(interfaceType.getColumn());
            thisInterface.setType(interfaceType);
            ((Classifier)interfaceType.getContainer()).getThisInterfaces().add(thisInterface);
        }

        instance=Instance(classifier=type:Classifier(interfaceType=InterfaceType)) -> {
            Interface interf = commonFactory.createInterface();
            interf.setIsPositive(true);
            interf.setType(interfaceType);
            interf.setLine(instance.getLine());
            interf.setColumn(instance.getColumn());
            instance.getInterfaces().add(interf);
        }

        PlaceHolder -> {
            // Do not dive into PlaceHolder elements
        }

        oObject=cmof.reflection.Object -> {
            dive;
        }
    }


    private Interface resolveChannelEndPointBinding(ChannelEndPointBinding binding, Media path) {
        if (binding.getChannelEndPointKind() == ChannelEndPointKind.ENV) {
            errors.add(new SemanticError((cmof.reflection.Object)path, "ENV is not supported in SDL-"));
            return null;
        } else if (binding.getChannelEndPointKind() == ChannelEndPointKind.AGENT) {
            // Resolve the referenced agent (the agent can also be a compositestate)
            NamedElement agentAsNamedElement = names.resolveAIdentifier(binding.getAgentIdentifier(), path,
                    Instance.class);
            Instance agent = null;
            if (checkIdentified(agentAsNamedElement, binding.getAgentIdentifier(), Instance.class)) {
                agent = (Instance)agentAsNamedElement;
            } else {
                return null;
            }

            // Resolve the referenced gate
            NamedElement gateAsNamedElement = names.resolveAIdentifierInContainer(binding.getGateIdentifier(),
                    (Container)agent.getType(), GateDefinition.class);
            GateDefinition gate = null;
            if (checkIdentified(gateAsNamedElement, binding.getGateIdentifier(), GateDefinition.class)) {
                gate = (GateDefinition)gateAsNamedElement;
            } else {
                return null;
            }

            // Search for the gate among the types of all interfaces of that agent
            for (Object interf: agent.getInterfaces()) {
                if (((Interface)interf).getType().equals(gate)) {
                    return (Interface)interf;
                }
            }
            errors.add(new SemanticError((cmof.reflection.Object)binding.getGateIdentifier(),
                    "reference does not reference a gate of the given agent"));
            return null;
        } else if (binding.getChannelEndPointKind() == ChannelEndPointKind.THIS) {
            // Find "this" agentType
            AgentTypeDefinition agentType = (AgentTypeDefinition)((ChannelDefinition)path.getContainer()).getContainer();
            // Resolve the gate
            NamedElement gateAsNamedElement = names.resolveAIdentifierInContainer(binding.getGateIdentifier(),
                    agentType, GateDefinition.class);
            GateDefinition gate = null;
            if (checkIdentified(gateAsNamedElement, binding.getGateIdentifier(), GateDefinition.class)) {
                gate = (GateDefinition)gateAsNamedElement;
            } else {
                return null;
            }
            // Search for the gate among the type of the this interfaces of this agentType
            for (Object interf: agentType.getThisInterfaces()) {
                if (((Interface)interf).getType().equals(gate)) {
                    return (Interface)interf;
                }
            }
            errors.add(new SemanticError((cmof.reflection.Object)binding.getGateIdentifier(),
                    "reference does not reference a gate of this agent"));
            return null;
        } else {
            throw new RuntimeException("unreachable code - 2");
        }
    }

    private pattern void resolveChannelEndPointBindings() {
        path=Media(ph=source:CsePlaceHolderForInterface(binding=channelEndPointBinding:ChannelEndPointBinding)) -> {
            Interface resolved = resolveChannelEndPointBinding(binding, path);
            if (resolved != null) {
                path.setSource(resolved);
                ((cmof.reflection.Object)ph).delete();
            }
        }
        path=Media(ph=sink:CsePlaceHolderForInterface(binding=channelEndPointBinding:ChannelEndPointBinding)) -> {
            Interface resolved = resolveChannelEndPointBinding(binding, path);
            if (resolved != null) {
                path.setSink(resolved);
                ((cmof.reflection.Object)ph).delete();
            }
        }
        default;
    }

    //private pattern void collectAllFeatures(Collection<Feature> result) {
    //    f=Feature -> {
    //        result.add(f);
    //    }
    //    CallNode(procedure=type:ModelElement) -> {
    //        collectAllFeatures(result, hub.sam.mof.mopatree.Mof2TreeNode.createNode((cmof.reflection.Object)procedure));
    //    }
    //    default;
    //}

    //private pattern void createImplicitInterfaceTypesForStateTypes() {
    //    st=CompositeStateTypeDefinition(sm=StateTransitionGraph) -> {
    //        // find all features
    //        Collection<Feature> theFeaturesOfThisType = new Vector<Feature>();
    //        collectAllFeatures(theFeaturesOfThisType, JMITreeNode.treeForObject(st));
    //
    //        // create the InterfaceType
    //        InterfaceType interfaceType = oExtent.getCommon().getInterfaceType().createInterfaceType();
    //        st.getInterfaces().add(interfaceType);
    //        for(Feature feature: theFeaturesOfThisType) {
    //            if (feature instanceof Sink) {
    //                interfaceType.getReceive().addAll(((Sink)feature).getItems());
    //            } else  if (feature instanceof Source) {
    //                if (!((feature instanceof ResetNode) || (feature instanceof SetNode))) {
    //                    interfaceType.getSend().addAll(((Source)feature).getItems());
    //                }
    //            } else {
    //                throw new RuntimeException("unreachable code");
    //            }
    //        }
    //    }
    //    default;
    //}
}
