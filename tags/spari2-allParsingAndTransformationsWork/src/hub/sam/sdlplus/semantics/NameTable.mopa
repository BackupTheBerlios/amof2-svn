package hub.sam.sdlplus.semantics;

import hub.sam.models.common.*;
import hub.sam.models.commondata.*;
import hub.sam.models.commonbehaviour.*;
import hub.sam.models.sdlplus.*;
import hub.sam.models.sdlplusconcretesyntaxextensions.*;
import hub.sam.mopa.trees.*;
import java.util.*;

public class NameTable {
    private Iterable<TreeNode> model;

    public NameTable(Iterable<TreeNode> model) {
        this.model = model;
    }

    /** uses resolveAIdentifierInContainer to resolve identifier in context, or
     * the surrounding namespaces of context. */
    public NamedElement resolveAIdentifier(Identifier identifier, ModelElement context, Class referenceTypeConstraint) {
        NamedElement result = null;
        result = resolveAIdentifierInContainer(identifier, getNamespaceOfElement((cmof.reflection.Object)context), referenceTypeConstraint);
        if (result == null) {
            result = resolveAIdentifierInContainer(identifier, getContainerOfElement((cmof.reflection.Object)context), referenceTypeConstraint);
        }
        return result;
    }

    /** resolves identifier in the given context (Container). Null is retured
     * if the identifier cannot be resolved at all, or when it can be resolved,
     * but resolves to a type not compatible with referenceTypeContstraint.
     */
    public NamedElement resolveAIdentifierInContainer(Identifier identifier, Container context, Class referenceTypeConstraint) {
        Qualifier qualifier = identifier.getQualifier();
        NamedElement result = null;
        try {
            if (qualifier == null) {
                result = resolveEntityInContainer(identifier.getName(), referenceTypeConstraint,
                        hub.sam.mof.mopatree.Mof2TreeNode.createNode((cmof.reflection.Object)context));
            } else {
                context = resolveAQualifier(qualifier, model);
                result = resolveEntityInContainer(identifier.getName(), referenceTypeConstraint,
                        hub.sam.mof.mopatree.Mof2TreeNode.createNode((cmof.reflection.Object)context));
            }
        } catch (NoMatchException e) {
            return null;
        }

        return result;
    }

    private pattern Namespace resolveAQualifier(Qualifier qualifier) {
        ns=Namespace provided (compareNames(ns.getName(), ((PathItem)qualifier.getPathItems().get(mopaDepth)).
                getName())) -> {
            PathItem currentItem = (PathItem)qualifier.getPathItems().get(mopaDepth);
            if (currentItem.getScopeUnitKind() != null) {
                ScopeUnitKind kind = currentItem.getScopeUnitKind();
                if (kind.equals(ScopeUnitKind.PACKAGE)) {
                    if (!(ns instanceof PackageDefinition)) {
                        break pattern;
                    }
                } else if (kind.equals(ScopeUnitKind.BLOCKTYPE)) {
                    if (!(ns instanceof AgentTypeDefinition)) {
                        if (!((AgentTypeDefinition)ns).getKind().equals(AgentKind.BLOCK)) {
                            break pattern;
                        }
                    }
                } else if (kind.equals(ScopeUnitKind.PROCESSTYPE)) {
                    if (!(ns instanceof AgentTypeDefinition)) {
                        if (!((AgentTypeDefinition)ns).getKind().equals(AgentKind.PROCESS)) {
                            break pattern;
                        }
                    }
                } else if (kind.equals(ScopeUnitKind.SYSTEMTYPE)) {
                    if (!(ns instanceof AgentTypeDefinition)) {
                        if (!((AgentTypeDefinition)ns).getKind().equals(AgentKind.SYSTEM)) {
                            break pattern;
                        }
                    }
                } else if (kind.equals(ScopeUnitKind.STATETYPE)) {
                    if (!(ns instanceof CompositeStateTypeDefinition)) {
                        break pattern;
                    }
                } else if (kind.equals(ScopeUnitKind.PROCEDURE)) {
                    if (!(ns instanceof ProcedureDefinition)) {
                        break pattern;
                    }
                } else {
                    break pattern;
                }
            }
            if (mopaDepth < qualifier.getPathItems().size() - 1) {
                return dive;
            } else {
                return ns;
            }
        }
    }

	/** Returns the Namespace that the given element is element of. */
    public Namespace getNamespaceOfElement(cmof.reflection.Object element) {
        cmof.reflection.Object result = element.container();
        if (result == null) {
            return null;
        } else if (result instanceof Namespace) {
            return (Namespace)result;
        } else {
            return getNamespaceOfElement(result);
        }
    }

	/** Returns the Container that a given element is contained in. */
    public Container getContainerOfElement(cmof.reflection.Object element) {
        cmof.reflection.Object result = element.container();
        if (result == null) {
            return null;
        } else if (result instanceof Container) {
            return (Container)result;
        } else {
            return getContainerOfElement(result);
        }
    }

    /**
     * Resolves the name in a the given container (TreeNode), searches in the
     * container itself, the contained ValueDataTypes, and then continues with
     * the parent containers
     */
    private pattern NamedElement resolveEntityInContainer(String name, Class referenceTypeConstraint) {
        ValueDataType(element=NamedElement) provided (compareNames(name, element.getName()) &&
                referenceTypeConstraint.isAssignableFrom(element.getClass())) -> {
            return element;
        }

        Container(element=NamedElement) provided ((compareNames(name, element.getName())) && (mopaDepth == 0) &&
                referenceTypeConstraint.isAssignableFrom(element.getClass())) -> {
            return element;
        }

        ns=Namespace provided (mopaDepth == 0) -> {
            NamedElement result = null;
            try {
               result = dive;
            } catch (NoMatchException e) {}
            if (result == null) {
                if (ns.getContainer() != null) {
                    try {
                        return resolveEntityInContainer(name, referenceTypeConstraint,
                                hub.sam.mof.mopatree.Mof2TreeNode.createNode((cmof.reflection.Object)ns.getContainer()));
                    } catch (NoMatchException e) {}
                }
            }
            return result;
        }
    }

	/**
	 * Helper function callback that compares two Strings. Can be overwriten to realize a NameTable for languages that
	 * differ names other than Sting.equal does.
	 */
    protected boolean compareNames(String one, String two) {
        if ((one == null) || (two == null)) {
            return false;
        }
        return one.equals(two);
    }
}
