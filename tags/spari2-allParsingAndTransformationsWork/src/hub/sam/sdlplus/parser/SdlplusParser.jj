/* vim:set fdm=marker: */

options {
  LOOKAHEAD = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = false;
  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(SdlplusParser)
package hub.sam.sdlplus.parser;

import java.util.*;
import cmof.reflection.*;
import cmof.common.*;
import hub.sam.mof.Repository;
import hub.sam.sdlplus.*;
import hub.sam.models.common.*;
import hub.sam.models.commonbehaviour.*;
import hub.sam.models.commondata.*;
import hub.sam.models.sdlplus.*;
import hub.sam.models.sdlplusconcretesyntaxextensions.*;

public class SdlplusParser {

    private CsePlaceHolderForGateDefinition createCsePlaceHolderForGateDefinition(Identifier identifier) {
        CsePlaceHolderForGateDefinition placeHolder = cse.createCsePlaceHolderForGateDefinition();
        placeHolder.setStringReference(identifier);
        return placeHolder;
    }

    private CsePlaceHolderForGeneralizableElement createCsePlaceHolderForGeneralizableElement(Identifier identifier) {
        CsePlaceHolderForGeneralizableElement placeHolder = cse.createCsePlaceHolderForGeneralizableElement();
        placeHolder.setStringReference(identifier);
        return placeHolder;
    }

    private CsePlaceHolderForLiteral createCsePlaceHolderForLiteral(Identifier identifier) {
        CsePlaceHolderForLiteral placeHolder = cse.createCsePlaceHolderForLiteral();
        placeHolder.setStringReference(identifier);
        return placeHolder;
    }

    private CsePlaceHolderForNamedElement createCsePlaceHolderForNamedElement(Identifier identifier) {
        CsePlaceHolderForNamedElement placeHolder = cse.createCsePlaceHolderForNamedElement();
        placeHolder.setStringReference(identifier);
        return placeHolder;
    }

    private CsePlaceHolderForSelector createCsePlaceHolderForSelector(Identifier identifier) {
        CsePlaceHolderForSelector placeHolder = cse.createCsePlaceHolderForSelector();
        placeHolder.setStringReference(identifier);
        return placeHolder;
    }

    private CsePlaceHolderForComItem createCsePlaceHolderForComItem(Identifier identifier) {
        CsePlaceHolderForComItem placeHolder = cse.createCsePlaceHolderForComItem();
        placeHolder.setStringReference(identifier);
        return placeHolder;
    }

    private CsePlaceHolderForState createCsePlaceHolderForState(Identifier identifier) {
        CsePlaceHolderForState placeHolder = cse.createCsePlaceHolderForState();
        placeHolder.setStringReference(identifier);
        return placeHolder;
    }

    private CsePlaceHolderForVariable createCsePlaceHolderForVariable(Identifier identifier) {
        CsePlaceHolderForVariable placeHolder = cse.createCsePlaceHolderForVariable();
        placeHolder.setStringReference(identifier);
        return placeHolder;
    }

    private void addContextM1(cmof.reflection.Object aObject, Token theContext) {
        try {
            SdlCompiler.getCompiler().addContextM1(aObject, theContext.beginLine, theContext.beginColumn);
        } catch (Exception e) {
            e.printStackTrace(System.err);
        }
    }

    private Qualifier copyQualifier(Qualifier qualifier) {
        Qualifier result = cse.createQualifier();
        result.setLine(qualifier.getLine());
        result.setColumn(qualifier.getColumn());
        result.getPathItems().addAll(copyPathItems(qualifier.getPathItems()));
        return result;
    }

    private List copyPathItems(ReflectiveCollection<? extends PathItem> pathItems) {
        List result = new Vector();
        for (PathItem orig: pathItems) {
            PathItem copy = cse.createPathItem();
            copy.setLine(orig.getLine());
            copy.setColumn(orig.getColumn());
            copy.setScopeUnitKind(orig.getScopeUnitKind());
            copy.setName(orig.getName());
            result.add(copy);
        }
        return result;
    }

    private Identifier copyIdentifier(Identifier identifier) {
        Identifier result = cse.createIdentifier();
        result.setLine(identifier.getLine());
        result.setColumn(identifier.getColumn());
        result.setName(identifier.getName());
        if (identifier.getQualifier() != null) {
            result.setQualifier(copyQualifier(identifier.getQualifier()));
        }
        return result;
    }

    private void addContextM1(cmof.reflection.Object aObject) {
        addContextM1(aObject, getToken(1));
    }

    private Map<StateAutomaton, Stop> stopsForAutomata = new HashMap<StateAutomaton, Stop>();

    private sdlplusFactory sdl = null;
    private sdlplusconcretesyntaxextensionsFactory cse = null;
    private commonbehaviourFactory behaviour = null;

    /**
     * Creates an SdlM2wcse extend and parses a input stream. Returns the
     * filled extend or throws an exception if a parse error occurs.
     */

    public void parse(Repository repo, Extent m2, Extent m1) throws Exception {
        sdl = (sdlplusFactory)repo.createFactory(m1, (cmof.Package)m2.query("Package:SdlPlus"));
        cse = (sdlplusconcretesyntaxextensionsFactory)repo.createFactory(m1, (cmof.Package)m2.query("Package:SdlPlusConcreteSyntaxExtensions"));
        behaviour = (commonbehaviourFactory)repo.createFactory(m1, (cmof.Package)m2.query("Package:CommonBehaviour"));
        sdl_specification();
    }
}

PARSER_END(SdlplusParser)

//{{{ Tokens and stuff
SKIP:
{
  < " " >
| < "\t" >
| < "\n" >
| < "\r" >
// | < "//" (~["\n"])* "\n" >
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
//| < "#" ([" ","\t"])* (["0"-"9"])+
//    (([" ","\t"])* "\"" (~["\""])+ "\""
//           ([" ","\t"])* (["0"-"9"])* ([" ","\t"])* (["0"-"9"])*)? "\n" >
}

TOKEN:
{
    <TOK_full_stop: ".">
|   <TOK_colon: ":">

//{{{ Keywords
|   <TOK_abstract: "ABSTRACT" | "abstract">
|   <TOK_active: "ACTIVE" | "active">
//|   <TOK_adding: "ADDING" | "adding">
|   <TOK_aggregation: "AGGREGATION" | "aggregation">
//|   <TOK_alternative: "ALTERNATIVE" | "alternative">
//|   <TOK_and: "AND" | "and">
|   <TOK_any: "ANY" | "any">
//|   <TOK_as: "AS" | "as">
//|   <TOK_association: "ASSOCIATION" | "association">
//|   <TOK_atleast: "ATLEAST" | "atleast">
|   <TOK_block: "BLOCK" | "block">
//|   <TOK_break: "BREAK" | "break">
|   <TOK_call: "CALL" | "call">
|   <TOK_channel: "CHANNEL" | "channel">
//|   <TOK_choice: "CHOICE" | "choice">
//|   <TOK_comment: "COMMENT" | "comment">
//|   <TOK_composition: "COMPOSITION" | "composition">
//|   <TOK_connect: "CONNECT" | "connect">
|   <TOK_connection: "CONNECTION" | "connection">
//|   <TOK_constants: "CONSTANTS" | "constants">
//|   <TOK_continue: "CONTINUE" | "continue">
|   <TOK_create: "CREATE" | "create">
|   <TOK_dcl: "DCL" | "dcl">
|   <TOK_decision: "DECISION" | "decision">
//|   <TOK_default: "DEFAULT" | "default">
|   <TOK_else: "ELSE" | "else">
|   <TOK_endalternative: "ENDALTERNATIVE" | "endalternative">
|   <TOK_endblock: "ENDBLOCK" | "endblock">
|   <TOK_endchannel: "ENDCHANNEL" | "endchannel">
|   <TOK_endconnection: "ENDCONNECTION" | "endconnection">
|   <TOK_enddecision: "ENDDECISION" | "enddecision">
|   <TOK_endexceptionhandler: "ENDEXCEPTIONHANDLER" | "endexceptionhandler">
//|   <TOK_endinterface: "ENDINTERFACE" | "endinterface">
//|   <TOK_endmacro: "ENDMACRO" | "endmacro">
//|   <TOK_endmethod: "ENDMETHOD" | "endmethod">
//|   <TOK_endobject: "ENDOBJECT" | "endobject">
|   <TOK_endoperator: "ENDOPERATOR" | "endoperator">
|   <TOK_endpackage: "ENDPACKAGE" | "endpackage">
|   <TOK_endprocedure: "ENDPROCEDURE" | "endprocedure">
|   <TOK_endprocess: "ENDPROCESS" | "endprocess">
//|   <TOK_endselect: "ENDSELECT" | "endselect">
|   <TOK_endstate: "ENDSTATE" | "endstate">
|   <TOK_endsubstructure: "ENDSUBSTRUCTURE" | "endsubstructure">
//|   <TOK_endsyntype: "ENDSYNTYPE" | "endsyntype">
|   <TOK_endsystem: "ENDSYSTEM" | "endsystem">
|   <TOK_endvalue: "ENDVALUE" | "endvalue">
|   <TOK_env: "ENV" | "env">
//|   <TOK_exception: "EXCEPTION" | "exception">
//|   <TOK_exceptionhandler: "EXCEPTIONHANDLER" | "exceptionhandler">
//|   <TOK_export: "EXPORT" | "export">
//|   <TOK_exported: "EXPORTED" | "exported">
//|   <TOK_external: "EXTERNAL" | "external">
//|   <TOK_fi: "FI" | "fi">
//|   <TOK_finalized: "FINALIZED" | "finalized">
//|   <TOK_for: "FOR" | "for">
|   <TOK_from: "FROM" | "from">
|   <TOK_gate: "GATE" | "gate">
//|   <TOK_handle: "HANDLE" | "handle">
//|   <TOK_if: "IF" | "if">
//|   <TOK_import: "IMPORT" | "import">
|   <TOK_in: "IN" | "in">
//|   <TOK_inherits: "INHERITS" | "inherits">
|   <TOK_inout: "INOUT" | "inout">
|   <TOK_input: "INPUT" | "input">
//|   <TOK_interface: "INTERFACE" | "interface">
|   <TOK_join: "JOIN" | "join">
|   <TOK_literals: "LITERALS" | "literals">
//|   <TOK_macro: "MACRO" | "macro">
//|   <TOK_macrodefinition: "MACRODEFINITION" | "macrodefinition">
//|   <TOK_macroid: "MACROID" | "macroid">
//|   <TOK_method: "METHOD" | "method">
//|   <TOK_methods: "METHODS" | "methods">
//|   <TOK_mod: "MOD" | "mod">
//|   <TOK_nameclass: "NAMECLASS" | "nameclass">
|   <TOK_nextstate: "NEXTSTATE" | "nextstate">
|   <TOK_nodelay: "NODELAY" | "nodelay">
//|   <TOK_none: "NONE" | "none">
//|   <TOK_not: "NOT" | "not">
|   <TOK_now: "NOW" | "now">
//|   <TOK_object: "OBJECT" | "object">
|   <TOK_offspring: "OFFSPRING" | "offspring">
//|   <TOK_onexception: "ONEXCEPTION" | "onexception">
|   <TOK_operator: "OPERATOR" | "operator">
|   <TOK_operators: "OPERATORS" | "operators">
//|   <TOK_optional: "OPTIONAL" | "optional">
//|   <TOK_or: "OR" | "or">
//|   <TOK_ordered: "ORDERED" | "ordered">
|   <TOK_out: "OUT" | "out">
|   <TOK_output: "OUTPUT" | "output">
|   <TOK_package: "PACKAGE" | "package">
|   <TOK_parent: "PARENT" | "parent">
//|   <TOK_priority: "PRIORITY" | "priority">
//|   <TOK_private: "PRIVATE" | "private">
|   <TOK_procedure: "PROCEDURE" | "procedure">
|   <TOK_process: "PROCESS" | "process">
//|   <TOK_protected: "PROTECTED" | "protected">
//|   <TOK_provided: "PROVIDED" | "provided">
|   <TOK_public: "PUBLIC" | "public">
//|   <TOK_raise: "RAISE" | "raise">
//|   <TOK_redefined: "REDEFINED" | "redefined">
|   <TOK_referenced: "REFERENCED" | "referenced">
//|   <TOK_rem: "REM" | "rem">
//|   <TOK_remote: "REMOTE" | "remote">
|   <TOK_reset: "RESET" | "reset">
|   <TOK_return: "RETURN" | "return">
//|   <TOK_save: "SAVE" | "save">
//|   <TOK_select: "SELECT" | "select">
|   <TOK_self: "SELF" | "self">
|   <TOK_sender: "SENDER" | "sender">
|   <TOK_set: "SET" | "set">
|   <TOK_signal: "SIGNAL" | "signal">
|   <TOK_signallist: "SIGNALLIST" | "signallist">
|   <TOK_signalset: "SIGNALSET" | "signalset">
//|   <TOK_size: "SIZE" | "size">
//|   <TOK_spelling: "SPELLING" | "spelling">
|   <TOK_start: "START" | "start">
|   <TOK_state: "STATE" | "state">
|   <TOK_stop: "STOP" | "stop">
//|   <TOK_struct: "STRUCT" | "struct">
|   <TOK_substructure: "SUBSTRUCTURE" | "substructure">
//|   <TOK_synonym: "SYNONYM" | "synonym">
//|   <TOK_syntype: "SYNTYPE" | "syntype">
|   <TOK_system: "SYSTEM" | "system">
|   <TOK_task: "TASK" | "task">
//|   <TOK_then: "THEN" | "then">
|   <TOK_this: "THIS" | "this">
|   <TOK_timer: "TIMER" | "timer">
|   <TOK_to: "TO" | "to">
//|   <TOK_try: "TRY" | "try">
|   <TOK_type: "TYPE" | "type">
//|   <TOK_use: "USE" | "use">
|   <TOK_value: "VALUE" | "value">
|   <TOK_via: "VIA" | "via">
|   <TOK_virtual: "VIRTUAL" | "virtual">
|   <TOK_with: "WITH" | "with">
//|   <TOK_xor: "XOR" | "xor">
//}}} end keywords

|   <TOK_qualifier_begin_sign: "<<">
|   <TOK_qualifier_end_sign: ">>">
|   <TOK_composite_begin_sign: "(.">
|   <TOK_composite_end_sign: ".)">
|   <TOK_is_assigned_sign: ":=">
|   <TOK_concatenation_sign: "//">
|   <TOK_greater_than_or_equals_sign: ">=">
|   <TOK_less_than_or_equals_sign: "<=">
|   <TOK_history_dash_sign: "-*">
|   <TOK_implies_sign: "=>">
|   <TOK_not_equals_sign: "/=">
|   <TOK_result_sign: "->">

|   <TOK_end: ";">

|   <TOK_TBD: "-!-EMPTY-!-">
}

TOKEN:
{
    <TCL_nat: (<TCL_decimaldigit>)+>
|   <TCL_name: (("_")*(<TCL_word>)(("_")+<TCL_word>)*("_")*) | ((<TCL_decimaldigit>)+((<TOK_full_stop>)(<TCL_decimaldigit>)+)*)>
|   <TCL_alphanumeric: ["a"-"z","A"-"Z","0"-"9","_"]>
|   <TCL_decimaldigit: ["0"-"9"]>
|   <TCL_word: (<TCL_alphanumeric>)+>
|   <TCL_string_literal:
        "\""
        (   (~["\"","\\","\n","\r"])
            | ("\\"
                ( ["n","t","b","r","f","\\","'","\""]
                | ["0"-"7"] ( ["0"-"7"] )?
                | ["0"-"3"] ["0"-"7"] ["0"-"7"]
                )
            )
        )*
        "\""
    >

}
//}}}

//{{{ visibility rules, names and identifiers

Identifier identifier():
{
    Identifier identifier = cse.createIdentifier();
    addContextM1((cmof.reflection.Object)identifier);
    String name = null;
    Qualifier qualifier = null;
}
{
    [ qualifier=qualifier() ] name=aName()
    {
        identifier.setName(name);
        if (qualifier != null) {
            identifier.setQualifier(qualifier);
        }
        return identifier;
    }
}

Identifier simple_identifier():
{
    Identifier identifier = cse.createIdentifier();
    addContextM1((cmof.reflection.Object)identifier);
    String name = null;
}
{
    name=aName()
    {
        identifier.setName(name);
        return identifier;
    }
}

Qualifier qualifier():
{
    Qualifier qualifier = cse.createQualifier();
    addContextM1((cmof.reflection.Object)qualifier);
    PathItem pathItem = null;
}
{
    <TOK_qualifier_begin_sign> pathItem=path_item() { qualifier.getPathItems().add(pathItem); }
    ( "/" pathItem=path_item() { qualifier.getPathItems().add(pathItem); } )* <TOK_qualifier_end_sign>
    {
        return qualifier;
    }
}

PathItem path_item():
{
    PathItem pathItem = cse.createPathItem();
    addContextM1((cmof.reflection.Object)pathItem);
    String name =  null;
    ScopeUnitKind scopeUnitKind;
}
{
    [ scopeUnitKind=scope_unit_kind() { pathItem.setScopeUnitKind(scopeUnitKind); } ] name=aName()
    {
        pathItem.setName(name);
        return pathItem;
    }
}

ScopeUnitKind scope_unit_kind():
{
    ScopeUnitKind sukKind = null;
}
{
    (
        <TOK_package> { sukKind = ScopeUnitKind.PACKAGE; }
    |
        (LOOKAHEAD(2)
            <TOK_system> <TOK_type> { sukKind = ScopeUnitKind.SYSTEMTYPE; }
        |
            <TOK_system> { sukKind = ScopeUnitKind.SYSTEMTYPE; }
        )
    |
        (LOOKAHEAD(2)
            <TOK_block> <TOK_type> { sukKind = ScopeUnitKind.BLOCKTYPE; }
        |
            <TOK_block> { sukKind = ScopeUnitKind.BLOCK; }
        )
    |
        (LOOKAHEAD(2)
            <TOK_process> <TOK_type> { sukKind = ScopeUnitKind.PROCESSTYPE; }
        |
            <TOK_process> { sukKind = ScopeUnitKind.PROCESS; }
        )
    |   (LOOKAHEAD(2)
            <TOK_state> <TOK_type> { sukKind = ScopeUnitKind.STATETYPE; }
        |
            <TOK_state> { sukKind = ScopeUnitKind.STATE; }
        )
    |
        <TOK_procedure> { sukKind = ScopeUnitKind.PROCEDURE; }
    |
        <TOK_signal> { sukKind = ScopeUnitKind.SIGNAL; }
    )
    {
        return sukKind;
    }
}
//}}}

//{{{ system and package
Collection<ModelElement> sdl_specification():
{
    Collection<ModelElement> topLevelModelElements = new Vector<ModelElement>();
    ModelElement element = null;
}
{
    ((element=package_definition(null) | element=agent_definition(null)) { topLevelModelElements.add(element); })* <EOF>
    {
        return topLevelModelElements;
    }
}

PackageDefinition package_definition(Namespace container):
{
    PackageDefinition packageDefinition = sdl.createPackageDefinition();
    addContextM1((cmof.reflection.Object)packageDefinition);
}
{
    <TOK_package> name(packageDefinition) // package_heading
    <TOK_end>
    ( entity_in_package(packageDefinition) )*
    <TOK_endpackage>
    //[ <TCL_name> ]
    <TOK_end>
    {
        if (container != null) {
            container.getContents().add(packageDefinition);
        }
        return packageDefinition;
    }
}

void entity_in_package(PackageDefinition packageDefinition):
{}
{
      package_definition(packageDefinition)
    | agent_type_definition(packageDefinition)
    | signal_definition(packageDefinition)
    | data_definition(packageDefinition)
    | procedure_definition(packageDefinition)
    | composite_state_type_definition(packageDefinition)
}

AgentDefinition agent_definition(Namespace container):
{
    AgentDefinition agent = sdl.createAgentDefinition();
    addContextM1((cmof.reflection.Object)agent);
}
{
    typebased_agent_definition(agent)
    {
        if (container != null) {
            container.getContents().add(agent);
        }
        return agent;
    }
}
//}}}

//{{{ agent_types
void agent_type_definition(Namespace container):
{
    AgentTypeDefinition agentType = sdl.createAgentTypeDefinition();
    addContextM1((cmof.reflection.Object)agentType);
}
{
    ( system_type_definition(agentType)
    | block_type_definition(agentType)
    | process_type_definition(agentType)
    )
    {
        container.getContents().add(agentType);
    }
}

void agent_type_structure(AgentTypeDefinition agentType):
{}
{
    (LOOKAHEAD(2) _agent_type_structure_wo_body(agentType) )*
    [ _agent_type_structure_body(agentType) ]
    // syntax constraint: if there is an agent_type_body, only entity_in_agent and gate_in_definition are allowed
    // syntax constraint: if there is not state_partitioning then there must be a agent_type_body
}

void _agent_type_structure_body(AgentTypeDefinition agentType):
{}
{//LOOKAHEAD(2)
    //  agent_type_body() // nicht in abstrakter syntax->metamodell?
    state_partitioning(agentType)
}

void _agent_type_structure_wo_body(AgentTypeDefinition agentType):
{}
{LOOKAHEAD(2)
      entity_in_agent(agentType)
    | channel_definition(agentType)
    | gate_in_definition(agentType)
    | agent_definition(agentType)
}

void state_partitioning(BodiedElement bodiedElement):
{}
{
    typebased_composite_state_definition(bodiedElement)
}

// not in abstract sdl+ syntax
//void agent_type_body():
//{}
//{
//    state_automaton()
//}

void entity_in_agent(AgentTypeDefinition agentType):
{}
{
      agent_type_definition(agentType)
    | signal_definition(agentType)
    | variable_definition(agentType)
    | data_definition(agentType)
    | timer_definition(agentType)
    | procedure_definition(agentType)
    | composite_state_type_definition(agentType)
}

void system_type_definition(AgentTypeDefinition agentType):
{}
{
    {
        agentType.setKind(AgentKind.SYSTEM);
    }
    <TOK_system> <TOK_type> name(agentType) // system type heading
    <TOK_end>
    agent_type_structure(agentType) <TOK_endsystem> <TOK_type>
    // [ <TCL_name>]
    <TOK_end>
}

void block_type_definition(AgentTypeDefinition agentType):
{}
{
    {
        agentType.setKind(AgentKind.BLOCK);
    }
    <TOK_block> <TOK_type> name(agentType) // block type heading
    <TOK_end>
    agent_type_structure(agentType) <TOK_endblock> <TOK_type>
    // [ <TCL_name>]
    <TOK_end>
}

void process_type_definition(AgentTypeDefinition agentType):
{}
{
    {
        agentType.setKind(AgentKind.PROCESS);
    }
    <TOK_process> <TOK_type> name(agentType) // process type heading
    <TOK_end>
    agent_type_structure(agentType) <TOK_endprocess> <TOK_type>
    // [ <TCL_name>]
    <TOK_end>
}

void composite_state_type_definition(Namespace container):
{
    CompositeStateTypeDefinition stateType = sdl.createCompositeStateTypeDefinition();
    addContextM1((cmof.reflection.Object)stateType);
}
{

    <TOK_state> <TOK_type> name(stateType) // composite state type heading
    <TOK_end>
    <TOK_substructure>
    (
    //not in abstract sdl+ syntax
        entity_in_composite_state(stateType) |
        gate_in_definition(stateType)
    )*
    composite_state_body(stateType)
    <TOK_endsubstructure> <TOK_state> <TOK_type>
    // [ <TCL_name> ]
    <TOK_end>
    {
        container.getContents().add(stateType);
    }
}

void composite_state_body(CompositeStateTypeDefinition stateType):
{
    StateAutomaton automaton = sdl.createStateTransitionGraph();
    addContextM1((cmof.reflection.Object)automaton);
    stateType.setBody(automaton);
}
{
    state_automaton(automaton)
}

void entity_in_composite_state(CompositeStateTypeDefinition stateType):
{}
{
      procedure_definition(stateType)
    | variable_definition(stateType)
    | data_definition(stateType)
}
//}}}

//{{{ types
void type_expression(TypedElement typedElement):
{
    Identifier identifier = null;
}
{
    identifier=identifier()
    {
        if (typedElement != null) {
            typedElement.setType(createCsePlaceHolderForNamedElement(identifier));
        }
    }
}

void typebased_agent_definition(AgentDefinition agent):
{}
{
    ( typebased_system_definition(agent)
    | typebased_block_definition(agent)
    | typebased_process_definition(agent)
    )
}

void typebased_system_definition(AgentDefinition agent):
{}
{
    <TOK_system> name(agent) <TOK_colon> type_expression(agent) <TOK_end>
    {
        agent.setInitialNumber(1);
    }
}

void typebased_block_definition(AgentDefinition agent):
{}
{
    <TOK_block> name(agent) [ number_of_instances(agent) ] <TOK_colon> type_expression(agent) <TOK_end>
}

void typebased_process_definition(AgentDefinition agent):
{}
{
    <TOK_process> name(agent) [ number_of_instances(agent) ] <TOK_colon> type_expression(agent) <TOK_end>
}

void number_of_instances(AgentDefinition agent):
{
    int initialNumber = 0;
}
{
    "(" [ initialNumber=integer() ] [ "," [ integer() ] ] ")"
    {
        agent.setInitialNumber(initialNumber);
    }
}

void typebased_composite_state_definition(BodiedElement bodiedElement):
{
    StateMachineDefinition stateMachine = sdl.createStateMachineDefinition();
    addContextM1((cmof.reflection.Object)stateMachine);
    bodiedElement.setBody(stateMachine);
}
{
    <TOK_state> <TOK_aggregation> name(stateMachine) <TOK_colon> type_expression(stateMachine) <TOK_end>
}
//}}}

//{{{ gates
void gate_in_definition(Classifier container):
{
    GateDefinition gate = sdl.createGateDefinition();
    addContextM1((cmof.reflection.Object)gate);
}
{
    <TOK_gate> name(gate) gate_constraint(gate) <TOK_end> [ gate_constraint(gate) <TOK_end> ]
    {
        container.getContents().add(gate);
        container.getInterfaces().add(gate);
    }
}

void gate_constraint(GateDefinition gate):
{
    Collection<Identifier> signals = new Vector<Identifier>();
    boolean in = false;
}
{
    ( <TOK_out> | <TOK_in> { in = true; } ) [ <TOK_with> signal_list(signals) ]
    {
        ReflectiveCollection addSignalsTo = null;
        if (in) {
            addSignalsTo = gate.getReceive();
            for (Identifier signal: signals) {
                addSignalsTo.add(createCsePlaceHolderForComItem(signal));
            }
        } else {
            addSignalsTo = gate.getSend();
            for (Identifier signal: signals) {
                addSignalsTo.add(createCsePlaceHolderForComItem(signal));
            }
        }
    }
}
//}}}

//{{{ procedure
void procedure_definition(Namespace container):
{
    ProcedureDefinition procedure = sdl.createProcedureDefinition();
    addContextM1((cmof.reflection.Object)procedure);
}
{
    <TOK_procedure> name(procedure) [ procedure_formal_parameters(procedure) ] [ result(procedure) ]  // heading
    <TOK_end>
    (LOOKAHEAD(2) entity_in_procedure(procedure) )*
    [ procedure_body(procedure) ]
    <TOK_endprocedure>
    // [ <TCL_name> ]
    <TOK_end>
    {
        container.getContents().add(procedure);
    }
}

void entity_in_procedure(ProcedureDefinition procedure):
{}
{
      procedure_definition(procedure)
    | composite_state_type_definition(procedure)
    |  variable_definition(procedure)
    | data_definition(procedure)
}

void procedure_body(ProcedureDefinition procedure):
{
    StateAutomaton automaton = sdl.createProcedureGraph();
    addContextM1((cmof.reflection.Object)automaton);
    procedure.setBody(automaton);
}
{
    state_automaton(automaton)
}

void procedure_formal_parameters(ProcedureDefinition procedure):
{}
{
    "(" formal_variable_parameter(procedure) ( "," formal_variable_parameter(procedure) )* ")"
}

void formal_variable_parameter(ParameterizedElement parameterized):
{
    ProcedureParameter parameter = sdl.createProcedureParameter();
    addContextM1((cmof.reflection.Object)parameter);
}
{
    parameter_kind(parameter) parameter_of_sort(parameter)
    {
        parameterized.getParameters().add(parameter);
        parameterized.getContents().add(parameter);
    }
}

void parameter_kind(ProcedureParameter parameter):
{}
{
      <TOK_in> { parameter.setKind(ProcedureParameterKind.INPARAMETER); }
    | <TOK_out> { parameter.setKind(ProcedureParameterKind.INOUTPARAMETER); } //??
    | <TOK_inout> { parameter.setKind(ProcedureParameterKind.INOUTPARAMETER); }
}

void parameter_of_sort(ProcedureParameter parameter):
{}
{
    name(parameter)
    //( "," name(parameter) )*
    sort_reference(parameter)
}

void result(TypedElement element):
{}
{
    <TOK_result_sign>
    //[LOOKAHEAD(2) aName() ]
    sort_reference(element)
}
//}}}

//{{{ communication
void channel_definition(Namespace container):
{
    ChannelDefinition channel = sdl.createChannelDefinition();
    addContextM1((cmof.reflection.Object)channel);
}
{
    <TOK_channel> name(channel) [ <TOK_nodelay> ] channel_path(channel) [ channel_path(channel) ]
    <TOK_endchannel>
    // [ <TCL_name> ]
    <TOK_end>
    {
        container.getContents().add(channel);
    }
}

void channel_path(ChannelDefinition channel):
{
    Collection<Identifier> signals = new Vector<Identifier>();
    ChannelPath path = sdl.createChannelPath();
    addContextM1((cmof.reflection.Object)path);
}
{
    <TOK_from> channel_endpoint(path, true)
    <TOK_to> channel_endpoint(path, false)
    // this is optional in real SDL-2000
    <TOK_with> signal_list(signals)
    <TOK_end>
    {
        for (Identifier identifier: signals) {
            // A Connection is a special Media with send = receive.
            path.getItems().add(createCsePlaceHolderForComItem(identifier));
        }
        channel.getContents().add(path);
    }
}

void channel_endpoint(ChannelPath path, boolean orig):
{
    Identifier agentIdentifier = null;
    Identifier gateIdentifier = null;
    ChannelEndPointKind channelEndPointKind = null;
}
{
    ( agentIdentifier=identifier() { channelEndPointKind = ChannelEndPointKind.AGENT; }
    | <TOK_env> { channelEndPointKind = ChannelEndPointKind.ENV; }
    | <TOK_this> { channelEndPointKind = ChannelEndPointKind.THIS; } )
    // this is optional in real SDL-2000
    <TOK_via> gateIdentifier=identifier()
    {
        if (orig) {
            CsePlaceHolderForInterface bindingClass = cse.createCsePlaceHolderForInterface();
            ChannelEndPointBinding binding = cse.createChannelEndPointBinding();
            bindingClass.setChannelEndPointBinding(binding);
            addContextM1((cmof.reflection.Object)binding);
            binding.setChannelEndPointKind(channelEndPointKind);

            if (agentIdentifier != null) {
                binding.setAgentIdentifier(agentIdentifier);
            }
            if (gateIdentifier != null) {
                binding.setGateIdentifier(gateIdentifier);
            }
            path.setSource(bindingClass);
        } else  {
            CsePlaceHolderForInterface bindingClass = cse.createCsePlaceHolderForInterface();
            ChannelEndPointBinding binding = cse.createChannelEndPointBinding();
            bindingClass.setChannelEndPointBinding(binding);
            addContextM1((cmof.reflection.Object)binding);
            binding.setChannelEndPointKind(channelEndPointKind);

            if (agentIdentifier != null) {
                binding.setAgentIdentifier(agentIdentifier);
            }
            if (gateIdentifier != null) {
                binding.setGateIdentifier(gateIdentifier);
            }
            path.setSink(bindingClass);
        }
    }
}

void signal_list(Collection<Identifier> list):
{}
{
    signal_list_item(list) [ "," signal_list(list) ]
}

void signal_list_item(Collection<Identifier> list):
{
    Identifier identifier = null;
}
{
    ( identifier=identifier()
    | "(" identifier=identifier() ")"
    )
    {
        list.add(identifier);
    }
}

void signal_definition(Namespace container):
{}
{
    <TOK_signal> signal_definition_item(container) ( "," signal_definition_item(container) )* <TOK_end>
}

void signal_definition_item(Namespace container):
{
    SignalDefinition signal = sdl.createSignalDefinition();
    addContextM1((cmof.reflection.Object)signal);
    container.getContents().add(signal);
}
{
    name(signal) [ "(" sort_reference_list(signal) ")" ]
}

void sort_reference_list(SignaturedElement signatured):
{
    Identifier sortReference;
    TypeReference typeReference;
}
{
    {
        typeReference = sdl.createSortReferenceIdentifier();
        addContextM1((cmof.reflection.Object)typeReference);
    }
    sortReference=aSort_reference()
    {
        typeReference.setType(createCsePlaceHolderForNamedElement(sortReference));
        signatured.getParameters().add(typeReference);
        signatured.getContents().add(typeReference);
    }
    (","
        {
            typeReference = sdl.createSortReferenceIdentifier();
            addContextM1((cmof.reflection.Object)typeReference);
        }
        sortReference=aSort_reference()
        {
            typeReference.setType(createCsePlaceHolderForNamedElement(sortReference));
            signatured.getParameters().add(typeReference);
            signatured.getContents().add(typeReference);
        }
    )*
}
//}}}

//{{{ state automaton
void state_automaton(StateAutomaton automaton):
{}
{
    [ start(automaton) ]
    (
        state_node(automaton)
    |
        free_action(automaton)
    )*
}

void free_action(StateAutomaton automaton):
{
    Connector state = sdl.createConnector();
    addContextM1((cmof.reflection.Object)state);
    automaton.getContents().add(state);
    Imidiate imidiate = behaviour.createImidiate();
    addContextM1((cmof.reflection.Object)imidiate);
    state.getSelectors().add(imidiate);
}
{
    <TOK_connection> name(state) transition(automaton, imidiate) [ <TOK_endconnection> <TOK_end> ]
}

void start(StateAutomaton automaton):
{
    StateStartNode state = sdl.createStateStartNode();
    addContextM1((cmof.reflection.Object)state);
    automaton.getContents().add(state);
    Imidiate imidiate = behaviour.createImidiate();
    addContextM1((cmof.reflection.Object)imidiate);
    state.getSelectors().add(imidiate);
}
{
    <TOK_start> <TOK_end> transition(automaton, imidiate)
}

void state_node(StateAutomaton automaton):
{}
{
    basic_state(automaton)
}

void basic_state(StateAutomaton automaton):
{
    Collection<State> states = new Vector<State>();
}
{
    <TOK_state> state_list(automaton, states) <TOK_end> input_part(automaton, states) <TOK_endstate>
    <TOK_end>
}

void state_list(StateAutomaton automaton, Collection<State> states):
{}
{
    state(automaton, states) ( "," state(automaton, states) )*
}

void state(StateAutomaton automaton, Collection<State> states):
{
    StateNode state = sdl.createStateNode();
    addContextM1((cmof.reflection.Object)state);
    automaton.getContents().add(state);
    states.add(state);
}
{
    name(state)
}

void input_part(StateAutomaton automaton, Collection<State> states):
{
    InputNode input = sdl.createInputNode();
    addContextM1((cmof.reflection.Object)input);
    for (State state: states) {
        state.getSelectors().add(input);
    }
}
{
    <TOK_input> input_list(input) <TOK_end> transition(automaton, input)
}

void input_list(InputNode input):
{}
{
    stimulus(input)
}

void stimulus(InputNode input):
{
    Identifier signal;
}
{
    signal=identifier() [ actual_parameters(input) ]
    {
        input.setType(createCsePlaceHolderForNamedElement(signal));
        input.getItems().add(createCsePlaceHolderForComItem(copyIdentifier(signal)));
    }
}

void transition(StateAutomaton automaton, Selector selector):
{
    SdlTransition transition = sdl.createSdlTransition();
    addContextM1((cmof.reflection.Object)transition);
    transition.setSelector(selector);
    automaton.getTransitions().add(transition);
}
{
    ( action_statement(automaton, transition) )* [ terminator_statement(automaton, transition) ]
}

void action_statement(StateAutomaton automaton, SdlTransition transition):
{}
{
    task(transition)
|
    output(transition)
|
    create_request(transition)
|
    decision(automaton, transition)
|
    set(transition)
|
    reset(transition)
|
    procedure_call(transition)
}

void terminator_statement(StateAutomaton automaton, SdlTransition transition):
{}
{
    (
        return_terminator(automaton, transition)
    |
        nextstate(transition)
    |
        join(transition)
    |
        stop(automaton, transition)
    ) <TOK_end>
}

void task(SdlTransition transition):
{
    SdlAssignment assignment = sdl.createSdlAssignment();
    addContextM1((cmof.reflection.Object)assignment, getToken(2));
    TaskNode task = sdl.createTaskNode();
    addContextM1((cmof.reflection.Object)task);
}
{
    <TOK_task> assignment(assignment) <TOK_end>
    {
        task.setAssignment(assignment);
        transition.getActions().add(task);
    }
}

void create_request(SdlTransition transition):
{
    CreateRequestNode create = sdl.createCreateRequestNode();
    addContextM1((cmof.reflection.Object)create);
    Identifier identifier;
    transition.getActions().add(create);
}
{
    <TOK_create> identifier=identifier() <TOK_end>
    {
        create.setType(createCsePlaceHolderForNamedElement(identifier));
    }
}

void procedure_call(SdlTransition transition):
{
    CallNode call = sdl.createCallNode();
    addContextM1((cmof.reflection.Object)call);
    Identifier procedure;
    transition.getActions().add(call);
}
{
    <TOK_call> procedure=identifier() [ actual_parameters(call) ] <TOK_end>
    {
        call.setType(createCsePlaceHolderForNamedElement(procedure));
    }
}

void actual_parameters(ArgumentedElement element):
{
    SdlExpression expression;
}
{
    "(" [ expression=expression()
        {
            element.getOperands().add(expression);
        }
    ( "," expression=expression()
        {
            element.getOperands().add(expression);
        }
    )* ] ")"
}

void output(SdlTransition transition):
{
    Identifier gate;
    List<OutputNode> outputs = new Vector<OutputNode>();
}
{
    <TOK_output> output_item(outputs) ( "," output_item(outputs) )*
    gate=communication_constraints() <TOK_end>
    {
        for(OutputNode output: outputs) {
            output.setViaGate(createCsePlaceHolderForGateDefinition(gate));
            transition.getActions().add(output);
        }
    }
}

void output_item(List<OutputNode> outputs):
{
    OutputNode output = sdl.createOutputNode();
    addContextM1((cmof.reflection.Object)output);
    Identifier signal;
}
{
    signal=identifier() [ actual_parameters(output) ]
    {
        output.setType(createCsePlaceHolderForNamedElement(signal));
        output.getItems().add(createCsePlaceHolderForComItem(copyIdentifier(signal)));
        outputs.add(output);
    }
}

Identifier communication_constraints():
{
    Identifier gate;
}
{
    <TOK_via> gate=identifier()
    {
        return gate;
    }
}

void decision(StateAutomaton automaton, SdlTransition transition):
{
    DecisionNode decisionNode;
    SdlExpression expr = null;
}
{
    <TOK_decision>
    (
        {
            decisionNode = sdl.createDecisionNode();
            addContextM1((cmof.reflection.Object)decisionNode, getToken(0));
        }
        expr=expression()
        <TOK_end> ( (answer_part(automaton, decisionNode))+ [ else_part(automaton, decisionNode) ] ) <TOK_enddecision><TOK_end>
        {
            decisionNode.setQuestion(expr);
        }
    |
        {
            decisionNode = cse.createAnyDecisionNode();
            addContextM1((cmof.reflection.Object)decisionNode, getToken(0));
        }
        <TOK_any>
        <TOK_end> ( (answer_part(automaton, decisionNode))+ ) <TOK_enddecision> <TOK_end>
    )
    {
        transition.setNextState(decisionNode);
        automaton.getContents().add(decisionNode);
    }
}

void answer_part(StateAutomaton automaton, DecisionNode decisionNode):
{
    DecisionAnswer answer = sdl.createDecisionAnswer();
    addContextM1((cmof.reflection.Object)answer);
    decisionNode.getSelectors().add(answer);
}
{
    "(" [ range_condition(answer, decisionNode) ] ")" <TOK_colon> [ transition(automaton, answer) ]
}

void else_part(StateAutomaton automaton, DecisionNode decisionNode):
{
    ElseAnswer answer = sdl.createElseAnswer();
    addContextM1((cmof.reflection.Object)answer);
    decisionNode.getSelectors().add(answer);
}
{
    <TOK_else> <TOK_colon> [ transition(automaton, answer) ]
}

void nextstate(SdlTransition transition):
{
    Identifier nextState;
}
{
    <TOK_nextstate> nextState=simple_identifier()
    {
        transition.setNextState(createCsePlaceHolderForState(nextState));
    }
}

void join(SdlTransition transition):
{}
{
    <TOK_join> nextstate(transition) //connector name
}

void stop(StateAutomaton automaton, SdlTransition transition):
{}
{
    <TOK_stop>
    {
        Stop stop = stopsForAutomata.get(automaton);
        if (stop == null) {
            stop = behaviour.createStop();
            addContextM1((cmof.reflection.Object)stop, getToken(0));
            automaton.getContents().add(stop);
            stopsForAutomata.put(automaton, stop);
        }
        transition.setNextState(stop);
    }
}

void return_terminator(StateAutomaton automaton, SdlTransition transition):
{
    ReturnNode returnNode = sdl.createReturnNode();
    addContextM1((cmof.reflection.Object)returnNode);
    SdlExpression expr;
}
{
    <TOK_return> [ expr=expression() { returnNode.setReturnExpression(expr); } ]
    {
        transition.setNextState(returnNode);
        automaton.getContents().add(returnNode);
    }
}
// }}}

//{{{ expressions & statements
void set(SdlTransition transition):
{}
{
    <TOK_set> set_clause(transition) ( "," set_clause(transition) )* <TOK_end>
}

void set_clause(SdlTransition transition):
{
    SetNode set = sdl.createSetNode();
    addContextM1((cmof.reflection.Object)set);
    Identifier timer;
    SdlExpression timeExpr;
}
{
    "(" timeExpr=expression() "," timer=identifier() [ actual_parameters(set) ] ")"
    {
        set.setTimeExpression(timeExpr);
        set.setType(createCsePlaceHolderForNamedElement(timer));
        set.getItems().add(createCsePlaceHolderForComItem(copyIdentifier(timer)));
        transition.getActions().add(set);
    }
}

void reset(SdlTransition transition):
{}
{
    <TOK_reset> "(" reset_clause(transition) ( "," reset_clause(transition) )* ")" <TOK_end>
}

void reset_clause(SdlTransition transition):
{
    ResetNode reset = sdl.createResetNode();
    addContextM1((cmof.reflection.Object)reset);
    Identifier timer;
}
{
    timer=identifier() [ actual_parameters(reset) ]
    {
        reset.setType(createCsePlaceHolderForNamedElement(timer));
        reset.getItems().add(createCsePlaceHolderForComItem(copyIdentifier(timer)));
        transition.getActions().add(reset);
    }
}

void assignment(SdlAssignment assignment):
{
    Identifier variable = null;
    SdlExpression expression;
}
{
    variable=identifier() <TOK_is_assigned_sign> expression=expression()
    {
        assignment.setVariable(createCsePlaceHolderForVariable(variable));
        assignment.setAssignmentExpression(expression);
    }
}

void range_condition(DecisionAnswer answer, Split decisionNode):
{
    RangeCondition condition = sdl.createRangeCondition();
    addContextM1((cmof.reflection.Object)condition);
    answer.setCondition(condition);
    ConditionItem singleCondition;
}
{
    singleCondition=range(decisionNode) { condition.getConditions().add(singleCondition); }
    ( "," range(decisionNode) { condition.getConditions().add(singleCondition); } )*
}

ConditionItem range(Split decisionNode):
{
    ConditionItem singleCondition;
}
{
    (LOOKAHEAD(closed_range())
        singleCondition=closed_range(decisionNode)
    |
        singleCondition=open_range(decisionNode)
    )
    {
        return singleCondition;
    }
}

ClosedRange closed_range(Split decisionNode):
{
    ClosedRange range = sdl.createClosedRange();
    addContextM1((cmof.reflection.Object)range);
    OpenRange range1, range2;
}
{
    range1=open_range(decisionNode) <TOK_colon> range2=open_range(decisionNode)
    {
        range.setUpperRange(range2);
        range.setLowerRange(range1);
        return range;
    }
}

OpenRange open_range(Split decisionNode):
{
    Identifier op;
    SdlExpression expr;
    OpenRange range = sdl.createOpenRange();
    addContextM1((cmof.reflection.Object)range);
}
{
    op=identifier() // operation (e.g. >=, <)
    expr=expression()
    {
        range.setType(createCsePlaceHolderForNamedElement(op));
        range.setExpression(expr);
        range.setDecision(decisionNode);
        return range;
    }
}
//}}}

//{{{ expressions
SdlExpression expression():
{
    SdlExpression expression;
}
{
    (LOOKAHEAD(operation_application())
        expression = operation_application()
    |
        expression = literal()
    |
        expression = variable_access()
    |
        "(" expression=expression() ")"
    |
        expression=imperative_expression()
    |
        expression=value_returning_call_node()
    )
    {
        return expression;
    }
}

SdlExpression operation_application():
{
    SdlOperationApplication opApp = sdl.createSdlOperationApplication();
    addContextM1((cmof.reflection.Object)opApp);
    Identifier operation = null;
}
{
    operation=identifier() actual_parameters(opApp)
    {
        opApp.setType(createCsePlaceHolderForNamedElement(operation));
        return opApp;
    }
}

SdlExpression variable_access():
{
    SdlVariableAccess expression = sdl.createSdlVariableAccess();
    addContextM1((cmof.reflection.Object)expression);
    Identifier identifier;
}
{
    identifier=identifier()
    {
        expression.setVariable(createCsePlaceHolderForVariable(identifier));
        return expression;
    }
}

SdlLiteral literal():
{
    SdlLiteral expression = sdl.createSdlLiteral();
    addContextM1((cmof.reflection.Object)expression);
}
{
    {
        String name;
        Identifier identifier=cse.createIdentifier();
        addContextM1((cmof.reflection.Object)identifier);
    }
    name=aStringName()
    {
        identifier.setName(name);
        expression.setLiteral(createCsePlaceHolderForLiteral(identifier));
        return expression;
    }
}

SdlExpression imperative_expression():
{
    SdlExpression expr;
}
{
    (
        expr=now_expression()
    |
        expr=pid_expression()
    |
        expr=timer_active_expression()
    )
    {
        return expr;
    }
}

SdlExpression now_expression():
{
    NowExpression expr = sdl.createNowExpression();
    addContextM1((cmof.reflection.Object)expr);
}
{
    <TOK_now>
    {
        return expr;
    }
}

SdlExpression pid_expression():
{
    SdlExpression expr;
}
{
    <TOK_self>
    {
        expr = sdl.createSelfExpression();
        addContextM1((cmof.reflection.Object)expr);
        return expr;
    }
|
    <TOK_sender>
    {
        expr = sdl.createSenderExpression();
        addContextM1((cmof.reflection.Object)expr);
        return expr;
    }
|
    <TOK_parent>
    {
        expr = sdl.createParentExpression();
        addContextM1((cmof.reflection.Object)expr);
        return expr;
    }
|
    <TOK_offspring>
    {
        expr = sdl.createOffspringExpression();
        addContextM1((cmof.reflection.Object)expr);
        return expr;
    }
}

SdlExpression timer_active_expression():
{
    TimerActiveExpression expr = sdl.createTimerActiveExpression();
    addContextM1((cmof.reflection.Object)expr);
    Identifier timer;
}
{
    <TOK_active> "(" timer=identifier() [ actual_parameters(expr) ] ")"
    {
        expr.setType(createCsePlaceHolderForNamedElement(timer));
        return expr;
    }
}

SdlExpression value_returning_call_node():
{
    ValueReturningCallNode expr = sdl.createValueReturningCallNode();
    addContextM1((cmof.reflection.Object)expr);
    Identifier procedure;
}
{
    <TOK_call> procedure=identifier() [ actual_parameters(expr) ]
    {
        expr.setType(createCsePlaceHolderForNamedElement(procedure));
        return expr;
    }
}
//}}}

//{{{ data definition
void variable_definition(Namespace namespace):
{}
{
    <TOK_dcl> variables_of_sort(namespace) ( "," variables_of_sort(namespace) )* <TOK_end>
}

void variables_of_sort(Namespace namespace):
{
    Identifier sortReference;
    Collection<String> names = new Vector<String>();
    String name;
    SdlExpression expr=null;
    Token context;
}
{
    {
        context = getToken(1);
    }
    name=aName() { names.add(name); }
    // ( "," name=aName() { names.add(name); )* multiple vars in one declaration disabled until the TBDs are done
    sortReference=aSort_reference()
    [ <TOK_is_assigned_sign> expr=expression() ]
    {
        boolean first = true;
        for (String varName: names) {
            VariableDefinition variable = null;
            if (first) {
                if (expr != null) {
                    VariableWithInitDefinition variableWithInit = sdl.createVariableWithInitDefinition();
                    variableWithInit.setAssignmentExpression(expr);
                    variableWithInit.setVariable(variableWithInit);
                    variable = variableWithInit;
                } else {
                    variable = sdl.createVariableDefinition();
                }
                addContextM1((cmof.reflection.Object)variable, context);
                variable.setName(varName);
                variable.setType(createCsePlaceHolderForNamedElement(sortReference));
                first = false;
            } else {
                //TBD set a COPY of expr
                //TBD bind with a COPY of sortReference
            }
            namespace.getContents().add(variable);
        }
    }
}

void timer_definition(Namespace namespace):
{}
{
    <TOK_timer> timer_definition_item(namespace) ( "," timer_definition_item(namespace) )* <TOK_end>
}

void timer_definition_item(Namespace namespace):
{
    SdlExpression expr;
    TimerDefinition timer = sdl.createTimerDefinition();
    addContextM1((cmof.reflection.Object)timer);
    namespace.getContents().add(timer);
}
{
    name(timer)
    [ "(" sort_reference_list(timer) ")" ]
}

void data_definition(Namespace namespace):
{}
{
    data_type_definition(namespace)
}

void data_type_definition(Namespace namespace):
{
    ValueDataTypeDefinition dataType = sdl.createValueDataTypeDefinition();
    addContextM1((cmof.reflection.Object)dataType);
    namespace.getContents().add(dataType);
}
{
    <TOK_value> <TOK_type> name(dataType) <TOK_end>
    [ data_type_constructor(dataType) ] [ operations(dataType) ]
    <TOK_endvalue> <TOK_type> /* [ aName() ] */ <TOK_end>
}

void operations(Namespace namespace):
{}
{
    operation_signatures(namespace)
    // no operation definitions, all operations are definied external implicitly
}

void operation_signatures(Namespace namespace):
{}
{
    <TOK_operators> operation_signature(namespace) <TOK_end> ( operation_signature(namespace) <TOK_end>)*
}

void operation_signature(Namespace namespace):
{
    OperationSignature operation = sdl.createOperationSignature();
    addContextM1((cmof.reflection.Object)operation);
    namespace.getContents().add(operation);
    String name;
}
{
    (
        name=aName()
    |
        name=aStringName()
    )
    [ "(" formal_parameter(operation) ( "," formal_parameter(operation) )* ")" ]
    [ result(operation) ]
    {
        operation.setName(name);
    }
}

void formal_parameter(SignaturedElement signatured):
{
    TypeReference typeReference = sdl.createSortReferenceIdentifier();
    addContextM1((cmof.reflection.Object)typeReference);
}
{
    /*typeReference_kind(typeReference)*/ <TOK_in> sort_reference(typeReference)
    {
        signatured.getParameters().add(typeReference);
        signatured.getContents().add(typeReference);
    }
}

void data_type_constructor(ValueDataType dataType):
{}
{
    literal_list(dataType)
}

void literal_list(ValueDataType dataType):
{}
{
    <TOK_literals> literal_signature(dataType) ( "," literal_signature(dataType) )* <TOK_end>
}

void literal_signature(ValueDataType dataType):
{
    Literal literal = sdl.createLiteralSignature();
    addContextM1((cmof.reflection.Object)literal);
    dataType.getLiterals().add(literal);
    String name;
}
{
    (
//        name=aName()
//    |
        name=aStringName()
    )
    {
        literal.setName(name);
        literal.setType(dataType);
    }
}

//}}}

//{{{ name & identifier & references
void name(NamedElement element):
{
    String name = null;
}
{
    name=aName()
    {
        element.setName(name);
    }
}

String aStringName():
{
    Token name;
}
{
    name=<TCL_string_literal>
    {
        String stringName = (String)name.image;
        stringName = stringName.substring(1, stringName.length() - 1);
        return stringName;
    }
}

String aName():
{
    Token name;
}
{
    name=<TCL_name>
    {
        return name.image;
    }
}

int integer():
{
    Token integer;
}
{
    integer=<TCL_nat>
    {
        return new Integer(integer.image).intValue();
    }
}


void sort_reference(TypeReference typedReference):
{
    Identifier identifier = null;
}
{
    identifier=identifier()
    {
        typedReference.setType(createCsePlaceHolderForNamedElement(identifier));
    }
}

Identifier aSort_reference():
{
    Identifier identifier = null;
}
{
    identifier=identifier()
    {
        return identifier;
    }
}
//}}}
